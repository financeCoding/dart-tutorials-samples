import "dart:async" as KB;import "dart:collection" as ZB;import "dart:uri" as ED;import "dart:html" as k;class pC{static const  qC="Chrome";static const  rC="Firefox";static const  sC="Internet Explorer";static const  tC="Safari";final  dC;final  minimumVersion;const pC(this.dC,[this.minimumVersion]);}class uC{final  name;const uC(this.name);}main(){dB=false;oB();pB();}class vC extends hB{var HD;static final nB=new k.DocumentFragment.html('''
      <div class="x-converter">
        <span> <content select=".label-one"></content> </span>
        <input type="text" style="text-align:right">
          &lt; &gt;
        <input type="text">
        <span> <content select=".label-two"></content> </span>
      </div>
    ''');var ID,JD;var KD; iC(){HD=createShadowRoot();KD=new CC(HD);HD.nodes.add(nB.clone(true));ID=HD.nodes[1].nodes[3];KD.listen(ID.onChange,(h){fC();});KD.listen(ID.onInput,(h){IB=ID.value;});KD.EB(()=>IB,(g){if(ID.value!=g)ID.value=g;},false,false);JD=HD.nodes[1].nodes[5];KD.listen(JD.onChange,(h){gC();});KD.listen(JD.onInput,(h){JB=JD.value;});KD.EB(()=>JB,(g){if(JD.value!=g)JD.value=g;},false,false);KD.DB();} kC(){KD.insert();} nC(){KD.remove();KD=ID=JD=null;} VB(){super.VB();if(HD is !k.ShadowRoot)HD=this;}var ratio=0.5;var IB='0';var JB='0'; fC(){var g=double.parse(IB);var h=g/ratio;JB=h.toStringAsFixed(2);} gC(){var h=double.parse(JB);var g=h*ratio;IB=g.toStringAsFixed(2);}} oB(){} pB(){var LD=k.document.body;var MD,ND,OD;var PD=new CC(LD);MD=LD.nodes[1].nodes[1];PD.EB(()=>0.62,(g){if(MD.xtag.ratio!=g)MD.xtag.ratio=g;},false,false);PD.q(new vC()..host=MD);ND=LD.nodes[1].nodes[3];PD.EB(()=>2.2,(g){if(ND.xtag.ratio!=g)ND.xtag.ratio=g;},false,false);PD.q(new vC()..host=ND);OD=LD.nodes[1].nodes[5];PD.EB(()=>17.06,(g){if(OD.xtag.ratio!=g)OD.xtag.ratio=g;},false,false);PD.q(new vC()..host=OD);PD.DB();PD.insert();}typedef  p( e);typedef  qB( changes);typedef  u();typedef  rB();class LB{final oldValue;final newValue;final  changes;LB(this.oldValue,this.newValue,[this.changes]); operator==(g){return g is LB&&oldValue==g.oldValue&&newValue==g.newValue&&changes==g.changes;} get hashCode=>yB(oldValue,newValue,changes); toString(){if(changes!=null)return '#<ChangeNotification to ${newValue}: ${changes}>';return '#<ChangeNotification from ${oldValue} to ${newValue}>';}}class aB{aB();} sB(g, i,[ debugName]){if(g is t){var h=g;return MB(h,(m){i(new LB(h,h,m));});}var j=new OB(g,i,debugName);if(!j.QD()){return tB;}return j.RD;} MB( g, i){if(g.jB==null)g.jB=new PB();var h=g.jB.add(i);return h.remove;}class t{} tB(){}var FB;var NB;class OB{static var uB=0;final  SD= ++OB.uB;final  TD;final  UD;final  VD;final  WD=new Map();final  XD=[] ;var YD=false;var ZD;OB(this.TD,this.UD,this.VD); toString()=>VD!=null?'<observer ${SD}: ${VD}>':'<observer ${SD}>'; QD(){var h=FB;FB=this;try {ZD=TD();if(ZD is Iterable&&ZD is !List&&ZD is !t){ZD=(ZD as Iterable).toList();}}catch (g,i){bB(g,i,TD,'from ${this}');ZD=null;}WD.forEach(aD);WD.clear();assert(FB==this);FB=h;bD();return XD.length>0;} cD( i){try {UD(i);}catch (g,h){bB(g,h,UD,'from ${this}');}} bD(){var g=ZD;if(g is !t)return;XD.add(MB(g,(h){cD(new LB(g,g,h));}));} aD( i, j){XD.add(MB(i,(m){if(YD)return;for(var g in m){var h=j[g.key];if(h!=null&&(h&g.type)!=0){YD=true;if(NB==null){NB=new ZB.SplayTreeMap();}NB[SD]=this;return;}}}));} RD(){for(var g in XD){g();}YD=false;}}typedef  vB(error,stackTrace,obj, message);var bB=wB; wB(i,g,h, j){print('web_ui.observe: unhandled error calling ${h} ${j}.\n' 'error:\n${i}\n\nstack trace:\n${g}');}class xB{xB();}class n<o>{var dD;var eD;var fD;var gD;n.FD( g,this.fD):gD=g{if(fD!=null)fD.hD++ ;} get next=>eD; get value=>gD;set value( g)=>gD=g; iD( g, h){eD=h;dD=g;if(g!=null)g.eD=this;if(h!=null)h.dD=this;return this;} append( g)=>new n<o>.FD(g,fD).iD(this,eD); remove(){if(fD==null)return;fD.hD-- ;if(dD!=null){dD.eD=eD;}else{fD.jD=eD;}if(eD!=null){eD.dD=dD;}else{fD.kD=dD;}eD=null;dD=null;fD=null;}}class PB<o> extends ZB.IterableBase<o>{var jD;var kD; get length=>hD;var hD=0;PB(){} get head=>jD; add( h){var g=new n<o>.FD(h,this);if(kD==null)return jD=kD=g;return kD=g.iD(kD,null);} addLast( g)=>add(g); addAll( g)=>g.forEach(add); get iterator=>new wC<o>(this);}class wC<o> implements Iterator<o>{var lD;var fD;var mD;var nD=-1;wC(this.fD){lD=new List<n>(fD.length);var h=0;var g=fD.head;while (g!=null){lD[h++ ]=g;g=g.next;}} get current=>mD; moveNext(){do{nD++ ;}while(nD<lD.length&&lD[nD].fD!=fD);if(nD<lD.length){mD=lD[nD].value;return true;}else{mD=null;return false;}}}cB(h,g)=>h.hashCode*31+g.hashCode;yB(h,g,i)=>cB(cB(h,g),i); zB(g){if(g is xB)return g.toString();g=g.toString();return BC(g)?g:'#';}const AC=const["http","https","ftp","mailto"]; BC( h){var g=new ED.Uri(h).scheme;if(g=='')return true;return AC.contains(g.toLowerCase())||"MAILTO"==g.toUpperCase();}abstract class w{ DB(){} insert(); remove();}class xC extends w{final  kB;var oD;final  listener;xC(this.kB,this.listener); insert(){oD=kB.listen(listener);} remove(){oD.cancel();oD=null;}}class yC extends w{final  mB;final  XB;final  lB;final  isFinal;var HB;yC(this.XB,this.mB,this.lB,this.isFinal); pD(g){mB(lB?zB(g):g);} insert(){if(isFinal){pD(XB());}else if(HB!=null){throw new StateError('data binding already attached.');}else{HB=FC(XB,(g)=>pD(g.newValue),'dom-property-binding');}} remove(){if(!isFinal){HB();HB=null;}}}class zC extends w{final q;zC(this.q); DB(){q..iC()..hC()..VB();} insert(){q..jC()..kC();} remove(){q..nC()..mC();}}class CC extends w{final  lC;final  children=[] ;final  nodes=[] ;CC(this.lC); listen( i, h){children.add(new xC(i,(g){h(g);GC();}));} EB(g,i,h,[isUrl=false]){children.add(new yC(g,i,isUrl,h));} q( g){children.add(new zC(g));} add( g)=>nodes.add(g); addAll( g)=>nodes.addAll(g); DB(){for(var g=0,h=children.length;g<h;g++ ){children[g].DB();}} insert(){for(var g=0,h=children.length;g<h;g++ ){children[g].insert();}} remove(){for(var g=children.length-1;g>=0;g-- ){children[g].remove();}children.clear();}}var dB=false; DC(g, m,[ debugName]){if(dB)return sB(g,m);if(m==null)return (){};if(AB==null)AB=new PB<BB>();var i;var h=l.KC;if(g is gB){i=(g as gB).qD;}else if(g is Function){i=g;try {var j=g();if(j is List){h=l.CB;}else if(j is Iterable){h=l.CB;i=()=>g().toList();}else if((j is ZB.LinkedHashMap)||(j is ZB.SplayTreeMap)){h=l.SB;}else if(j is Map){h=l.RB;}}catch (s,oC){print('error: evaluating ${debugName!=null?debugName:"<unnamed>"} ' 'watcher threw error (${s}, ${oC})');}}else if(g is List){i=()=>g;h=l.CB;}else if(g is Iterable){i=()=>g.toList();h=l.CB;}else if((g is ZB.LinkedHashMap)||(g is ZB.SplayTreeMap)){i=()=>g;h=l.SB;}else if(g is Map){i=()=>g;h=l.RB;}var v=EC(h,i,m,debugName);var YB=AB.add(v);return YB.remove;} EC( j, g, i, h){switch (j){case l.CB:return new AD(g,i,h);case l.SB:return new CD(g,i,h);case l.RB:return new BD(g,i,h);default:return new BB(g,i,h);}} FC(h,i,[debugName]){var j=DC(h,i,debugName);var g=h;if(g is Function){g=g();}if(g is Iterable&&g is !List){g=g.toList();}i(new LB(null,g));return j;}var AB;class BB{final  WB;final  qD;final  rD;var sD;BB(this.qD,this.rD,this.WB){sD=qD();} toString()=>WB==null?'<unnamed>':WB; eC(){var g=tD();if(uD(g)){var h=sD;vD(g);rD(new LB(h,g));return true;}return false;} uD(g)=>sD!=g; vD(g){sD=g;}tD(){try {return qD();}catch (g,h){print('error: evaluating ${this} watcher threw an exception (${g}, ${h})');}return sD;}}final  eB=10; GC(){if(AB==null)return;var g;var h=0;do{g=false;for(var i in AB){if(i.eC()){g=true;}}}while(g&& ++h<eB);if(h==eB){print('Possible loop in watchers propagation, stopped dispatch.');}}typedef  fB<HC>();typedef  IC<HC>( value);class gB<HC>{gB();}class AD<HC> extends BB{AD(g, i, h):super(g,i,h){vD(tD());} uD( g){return QB(sD,g);} vD(g){sD=new List<HC>.from(g);}}class BD<GB,JC> extends BB{BD(g, i, h):super(g,i,h){vD(tD());} uD( g){var i=sD.keys;if(i.length!=g.keys.length)return true;var j=i.iterator;while (j.moveNext()){var h=j.current;if(!g.containsKey(h))return true;if(sD[h]!=g[h])return true;}return false;} vD(g){sD=new Map<GB,JC>.from(g);}}class CD<GB,JC> extends BB{CD(g, i, h):super(g,i,h){vD(tD());} uD( g){return QB(g.keys,sD.keys)||QB(g.values,sD.values);} vD(g){sD=new ZB.LinkedHashMap.from(g);}} QB( i, j){var h=i.iterator;var g=j.iterator;while (h.moveNext()){if(!g.moveNext())return true;if(h.current!=g.current)return true;}return g.moveNext();}class l{final wD;const l.GD(this.wD);toString()=>'Enum.${wD}';static const CB=const l.GD('LIST');static const RB=const l.GD('HASH_MAP');static const SB=const l.GD('ORDERED_MAP');static const KC=const l.GD('OTHER');}abstract class hB implements k.Element{var xD;var yD; get host{if(xD==null)throw new StateError('host element has not been set.');return xD;}set host( g){if(g==null){throw new ArgumentError('host must not be null.');}if(g.xtag!=null){throw new ArgumentError('host must not have its xtag property set.');}if(xD!=null){throw new StateError('host can only be set once.');}g.xtag=this;xD=g;}createShadowRoot(){if(iB){return host.createShadowRoot();}if(yD==null)yD=[] ;yD.add(new k.DivElement());return yD.last;} hC(){} jC(){} mC(){} VB(){if(iB)return;if(yD.length==0){throw new StateError('Distribution algorithm requires at least one shadow' ' root and can only be run once.');}var j=yD;var g=j.removeLast();var YB=g;var s=new List.from(nodes);var m=[] ;var v=[] ;while (true){s=zD(g,s);var h=g.query('shadow');if(h!=null){if(j.length>0){g=j.removeLast();m.add(h);v.add(g);}else{UB(h,s);break;}}else{break;}}for(int i=0;i<m.length;i++ ){var h=m[i];var g=v[i];UB(h,g.nodes);}nodes.clear();nodes.addAll(YB.nodes);} zD( v, j){for(var g in v.queryAll('content')){if(!MC(g))continue;var i=g.attributes['select'];if(i==null||i=='')i='*';var h=[] ;var s=[] ;for(var m in j){(LC(m,i)?h:s).add(m);}if(h.length==0){h=g.nodes;}UB(g,h);j=s;}return j;}static  LC( h, g){if(h is !k.Element)return g=='*';return (h as k.Element).matches(g);}static  TB( g)=>g.tagName=='CONTENT'||g.tagName=='SHADOW';static  MC( g){assert(TB(g));for(g=g.parent;g!=null;g=g.parent){if(TB(g))return false;}return true;}static  UB( g, h){assert(TB(g));g.parent.insertAllBefore(h,g);g.remove();} get nodes=>host.nodes; replaceWith( g){host.replaceWith(g);} remove()=>host.remove();set text( g){host.text=g;} contains( g)=>host.contains(g); insertBefore( g, h)=>host.insertBefore(g,h); insertAllBefore( g, h)=>host.insertAllBefore(g,h); get attributes=>host.attributes; get children=>host.children; clone( g)=>host.clone(g); get parent=>host.parent; get parentNode=>host.parentNode; get nodeValue=>host.nodeValue; get id=>host.id; set innerHtml( g){host.innerHtml=g;} get tagName=>host.tagName; matches( g)=>host.matches(g); query( g)=>host.query(g); queryAll( g)=>host.queryAll(g); get RC=>host.RC; get SC=>host.SC; get VC=>host.VC; TC( g)=>host.TC(g); UC( g)=>host.UC(g); XC( g)=>host.XC(g); YC( g)=>host.YC(g); cC( h, g)=>host.cC(h,g);get PC=>host.PC; get QC=>host.QC; get localName=>host.localName; get WC=>host.WC; OC( h, g,[ useCapture]){host.OC(h,g,useCapture);} ZC( g)=>host.ZC(g); aC( h, g,[ useCapture]){host.aC(h,g,useCapture);} bC( g, h)=>host.bC(g,h);get xtag=>host.xtag;set xtag(g){host.xtag=g;} append( g)=>host.append(g); get onChange=>host.onChange; get onInput=>host.onInput;}var NC=false; get iB=>NC&&k.ShadowRoot.supported;//@ sourceMappingURL=convertThis.html_bootstrap.dart.map
